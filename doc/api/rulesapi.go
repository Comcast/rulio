// Copyright 2015 Comcast Cable Communications Management, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// End Copyright

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strings"
)

var run = flag.Bool("run", true, "Run the requests against an endpoint")
var format = flag.String("format", "markdown", "Output format: markdown or raml")
var form = flag.Bool("form", true, "Generate forms for live testing")
var link = flag.Bool("link", true, "Generate request links")
var liveTarget = flag.String("target", "http://localhost:8001", "Target for form submissions")
var endpoint = flag.String("endpoint", "http://localhost:8001/api/json", "endpoint for generating requests")
var overview = flag.String("overview", "overview.json", "overview JSON documentation")
var summary = flag.String("summary", "summary.md", "summary documentation")
var apifile = flag.String("api", "api.json", "api JSON documentation")

func multiline(s interface{}) string {
	switch s.(type) {
	case string:
		return s.(string)
	case []interface{}:
		acc := ""
		for _, line := range s.([]interface{}) {
			acc += line.(string) + "\n"
		}
		return acc
	default:
		panic(fmt.Errorf("Multiline Can't handle %T (%v)", s, s))
	}
}

func output(media string, control string, args ...interface{}) {
	if media == *format {
		fmt.Printf(control, args...)
	}
}

func indent(s string, spaces int) string {
	ind := ""
	for i := 0; i < spaces; i++ {
		ind += " "
	}
	return ind + strings.Replace(s, "\n", "\n"+ind, -1)
}

func main() {

	flag.Parse()

	overview, err := ioutil.ReadFile(*overview)
	if err != nil {
		panic(err)
	}
	var top map[string]string
	err = json.Unmarshal(overview, &top)
	if err != nil {
		panic(err)
	}
	output("raml", "#%%RAML 0.8\n\n")
	output("raml", "#%% Generated by rulesapi\n\n")
	output("raml", "title: %s\n", top["title"])
	output("raml", "protocols: [ HTTP ]\n")
	output("raml", "version: %s\n", top["version"])
	output("raml", "mediaType: application/json\n")

	md, err := ioutil.ReadFile(*summary)
	if err != nil {
		panic(err)
	}
	output("markdown", "%s\n\n", string(md))
	output("markdown", "<!-- Generated by rulesapi -->\n\n")

	output("raml", `documentation:
  - title: Overview
    content: |
%s
`, indent(string(md), 6))

	body, err := ioutil.ReadFile(*apifile)
	if err != nil {
		panic(err)
	}

	var apis []map[string]interface{}
	err = json.Unmarshal(body, &apis)

	if err != nil {
		panic(err)
	}

	output("markdown", "## Index\n\n")
	for i, api := range apis {
		uri := api["op"].(string)
		anchor := strings.Replace(uri, "/", "", -1)
		desc := api["description"]
		var short string
		switch desc.(type) {
		case string:
			short = desc.(string)
		case []interface{}:
			short = desc.([]interface{})[0].(string)
		}
		output("markdown", "%d. <a href=\"#%s\">%s</a> %s\n", i+1, anchor, uri, short)
	}
	output("markdown", "\n\n")

	output("markdown", "## Operations\n\n")
	for _, api := range apis {
		uri := api["op"]
		log.Printf("uri %v", uri)
		anchor := strings.Replace(uri.(string), "/", "", -1)
		output("markdown", "<a name=\"wiki-%s\">\n", anchor)
		output("markdown", "### %s\n\n", uri)
		output("markdown", "%s\n\n", multiline(api["description"]))

		output("raml", "%s:\n", uri.(string))
		output("raml", "  post:\n")
		output("raml", "    description: |\n")
		output("raml", "%s\n", indent(multiline(api["description"]), 6))
		output("raml", "    body:\n")
		output("raml", "      application/json:\n")
		output("raml", "        schema: |\n")
		output("raml", "%s\n", indent(`{
  "$schema": "http://json-schema.org/draft-03/schema",
  "type": "object",
  "properties": {`, 10))

		ps, given := api["params"]
		if given {
			params := ps.(map[string]interface{})
			i := 0
			for name, desc := range params {
				i++
				output("raml", indent(fmt.Sprintf(`"%s": {"type":"string","description":"%s"}`, name, desc), 14))
				if i < len(params) {
					output("raml", ",")
				}
				output("raml", "\n")
			}
		}

		output("raml", "%s\n", indent(`  }
}`, 10))

		ps, given = api["params"]
		if given {
			params := ps.(map[string]interface{})
			i := 1
			for name, desc := range params {
				output("markdown", "%d. `%s`: %v\n", i, name, desc)
				i++
			}
			output("markdown", "\n\n")
		}

		r, given := api["exampleRequest"].(map[string]interface{})
		if given {
			r["uri"] = uri
			js, err := json.MarshalIndent(r, "", "  ")
			if err != nil {
				panic(err)
			}
			output("markdown", "Example request:\n\n")
			exampleRequest := strings.Replace(string(js), `\"`, `\\"`, -1)
			output("markdown", "```Javascript\n%s\n```\n\n", exampleRequest)

			output("raml", "        example: |\n")
			output("raml", indent(exampleRequest, 10))
			output("raml", "\n")

			if *link {
				oneLine, err := json.Marshal(r)
				if err != nil {
					panic(err)
				}
				enc := url.QueryEscape(string(oneLine))
				url := fmt.Sprintf("%s/api/json?%s", *liveTarget, enc)
				output("markdown", "<a href=\"%s\"><code>%s</code></a>\n\n", url, url)
			}

			if *run {
				js, err = json.Marshal(r)
				if err != nil {
					log.Printf("Error %v: %v (%T)", err, r, r)
					panic(err)
				}
				got, err := http.Post(*endpoint, "application/json", bytes.NewBuffer(js))
				if err != nil {
					log.Printf("Error %v: %v (%T)", err, r, r)
					panic(err)
				}
				defer got.Body.Close()
				js, err = ioutil.ReadAll(got.Body)
				var o interface{}
				err = json.Unmarshal(js, &o)
				if err != nil {
					// output("markdown", "unmarshal error on '%s' (%v)\n", js, js)
					log.Printf("Warning %v: %v (%T)", err, r, r)
					// But try to allow the non-JSON response through ...
				} else {
					js, err = json.MarshalIndent(o, "", "  ")
					if err != nil {
						log.Printf("Error %v: %v (%T)", err, r, r)
						panic(err)
					}
				}
				output("markdown", "Response:\n\n")
				s := strings.Replace(string(js), `\"`, `\\"`, -1)
				output("markdown", "```Javascript\n%s\n```\n\n", s)

				output("raml", `    responses:
      200:
        body:
          application/json:
            example: |
`)
				output("raml", "%s", indent(s, 14))
				output("raml", "\n")

			} else {
				r, given = api["exampleResponse"].(map[string]interface{})
				if given {
					r["uri"] = uri
					js, err := json.MarshalIndent(r, "", "  ")
					if err != nil {
						panic(err)
					}
					output("markdown", "Canned response:\n\n")
					output("markdown", "```Javascript\n%s\n```\n\n", string(js))
				}
			}

			if *form {
				output("markdown", "Try it live:\n\n")
				lines := strings.Count(exampleRequest, "\n") + 1
				if 14 < lines {
					lines = 14
				}
				output("markdown", `<form action="%s/api/json">
<code>%s/api/json</code>
<br>
<textarea name="json" rows="%d" cols="80">
%s
</textarea>
<br>
<input type="submit" name="submit" value="Try it">
</form>
`, *liveTarget, *liveTarget, lines, exampleRequest)
			}

		}

	}
}
